{
  "version": 3,
  "sources": ["../../react-intersection-observer-hook/src/utils.ts", "../../react-intersection-observer-hook/src/useIntersectionObserver.ts", "../../react-intersection-observer-hook/src/useTrackVisibility.ts"],
  "sourcesContent": ["type EntryCallback = (entry: IntersectionObserverEntry) => void;\n\ntype CachedObserver = {\n  observer: IntersectionObserver;\n  entryCallbacks: Map<Element, EntryCallback>;\n};\n\ntype ObserverCache = Map<string, CachedObserver>;\n\ntype ObserverCachesByRoot = Map<\n  IntersectionObserverInit['root'],\n  ObserverCache\n>;\n\nexport type CachedIntersectionObserver = {\n  observe: (\n    node: Element,\n    callback: (entry: IntersectionObserverEntry) => void,\n  ) => void;\n  unobserve: (node: Element) => void;\n};\n\nexport function createObserverCache() {\n  const cachesByRoot: ObserverCachesByRoot = new Map();\n\n  function getObserver({\n    root,\n    rootMargin,\n    threshold,\n  }: IntersectionObserverInit): CachedIntersectionObserver {\n    let cacheByRoot = cachesByRoot.get(root);\n\n    if (!cacheByRoot) {\n      cacheByRoot = new Map();\n      cachesByRoot.set(root, cacheByRoot);\n    }\n\n    const cacheKey = JSON.stringify({ rootMargin, threshold });\n    let cachedObserver = cacheByRoot.get(cacheKey);\n\n    if (!cachedObserver) {\n      const entryCallbacks = new Map<Element, EntryCallback>();\n\n      const observer = new IntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            const callback = entryCallbacks.get(entry.target);\n            callback?.(entry);\n          });\n        },\n        { root, rootMargin, threshold },\n      );\n\n      cachedObserver = { observer, entryCallbacks };\n\n      cacheByRoot.set(cacheKey, cachedObserver);\n    }\n\n    return {\n      observe: (\n        node: Element,\n        callback: (entry: IntersectionObserverEntry) => void,\n      ) => {\n        cachedObserver?.entryCallbacks.set(node, callback);\n        cachedObserver?.observer.observe(node);\n      },\n      unobserve: (node: Element) => {\n        cachedObserver?.entryCallbacks.delete(node);\n        cachedObserver?.observer.unobserve(node);\n      },\n    };\n  }\n\n  return { getObserver };\n}\n", "import { useState, useCallback, useRef } from 'react';\nimport { CachedIntersectionObserver, createObserverCache } from './utils';\nimport { Omit } from './types';\n\nconst DEFAULT_ROOT_MARGIN = '0px';\nconst DEFAULT_THRESHOLD = [0];\n\nexport type IntersectionObserverHookArgs = Omit<\n  IntersectionObserverInit,\n  'root'\n>;\n\nexport type IntersectionObserverHookRefCallbackNode = Element | null;\n\nexport type IntersectionObserverHookRefCallback = (\n  node: IntersectionObserverHookRefCallbackNode,\n) => void;\n\nexport type IntersectionObserverHookRootRefCallbackNode = IntersectionObserverInit['root'];\n\nexport type IntersectionObserverHookRootRefCallback = (\n  node: IntersectionObserverHookRootRefCallbackNode,\n) => void;\n\nexport type IntersectionObserverHookResult = [\n  IntersectionObserverHookRefCallback,\n  {\n    entry: IntersectionObserverEntry | undefined;\n    rootRef: IntersectionObserverHookRootRefCallback;\n  },\n];\n\nconst observerCache = createObserverCache();\n\n// For more info:\n// https://developers.google.com/web/updates/2016/04/intersectionobserver\n// https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\nfunction useIntersectionObserver(\n  args?: IntersectionObserverHookArgs,\n): IntersectionObserverHookResult {\n  const rootMargin = args?.rootMargin ?? DEFAULT_ROOT_MARGIN;\n  const threshold = args?.threshold ?? DEFAULT_THRESHOLD;\n\n  const nodeRef = useRef<IntersectionObserverHookRefCallbackNode>(null);\n  const rootRef = useRef<IntersectionObserverHookRootRefCallbackNode>(null);\n  const observerRef = useRef<CachedIntersectionObserver | null>(null);\n\n  const [entry, setEntry] = useState<IntersectionObserverEntry>();\n\n  const observe = useCallback(() => {\n    const node = nodeRef.current;\n\n    if (!node) {\n      setEntry(undefined);\n      return;\n    }\n\n    const observer = observerCache.getObserver({\n      root: rootRef.current,\n      rootMargin,\n      threshold,\n    });\n\n    observer.observe(node, (observedEntry) => {\n      setEntry(observedEntry);\n    });\n\n    observerRef.current = observer;\n  }, [rootMargin, threshold]);\n\n  const unobserve = useCallback(() => {\n    const currentObserver = observerRef.current;\n    const node = nodeRef.current;\n\n    if (node) {\n      currentObserver?.unobserve(node);\n    }\n\n    observerRef.current = null;\n  }, []);\n\n  // React will call the ref callback with the DOM element when the component mounts,\n  // and call it with null when it unmounts.\n  // So, we don't need an useEffect etc to unobserve nodes.\n  // When nodeRef.current is null, it will be unobserved and observe function\n  // won't do anything.\n  const refCallback = useCallback<IntersectionObserverHookRefCallback>(\n    (node) => {\n      unobserve();\n      nodeRef.current = node;\n      observe();\n    },\n    [observe, unobserve],\n  );\n\n  const rootRefCallback = useCallback<IntersectionObserverHookRootRefCallback>(\n    (rootNode) => {\n      unobserve();\n      rootRef.current = rootNode;\n      observe();\n    },\n    [observe, unobserve],\n  );\n\n  return [refCallback, { entry, rootRef: rootRefCallback }];\n}\n\nexport default useIntersectionObserver;\n", "import { useState } from 'react';\nimport useIntersectionObserver, {\n  IntersectionObserverHookArgs,\n  IntersectionObserverHookResult,\n} from './useIntersectionObserver';\n\nexport type TrackVisibilityHookArgs = IntersectionObserverHookArgs;\n\nexport type TrackVisibilityHookResult = [\n  IntersectionObserverHookResult[0],\n  IntersectionObserverHookResult[1] & {\n    isVisible: boolean;\n    wasEverVisible: boolean;\n  },\n];\n\nfunction useTrackVisibility(\n  args?: IntersectionObserverHookArgs,\n): TrackVisibilityHookResult {\n  const [ref, result] = useIntersectionObserver(args);\n  const isVisible = Boolean(result.entry?.isIntersecting);\n  const [wasEverVisible, setWasEverVisible] = useState(isVisible);\n\n  if (isVisible && !wasEverVisible) {\n    setWasEverVisible(true);\n  }\n\n  return [ref, { ...result, isVisible, wasEverVisible }];\n}\n\nexport default useTrackVisibility;\n"],
  "mappings": "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",
  "names": ["createObserverCache", "cachesByRoot", "Map", "getObserver", "root", "rootMargin", "threshold", "cacheByRoot", "get", "set", "cacheKey", "JSON", "stringify", "cachedObserver", "entryCallbacks", "observer", "IntersectionObserver", "entries", "forEach", "entry", "callback", "target", "observe", "node", "unobserve", "DEFAULT_ROOT_MARGIN", "DEFAULT_THRESHOLD", "observerCache", "useIntersectionObserver", "args", "nodeRef", "useRef", "rootRef", "observerRef", "useState", "setEntry", "useCallback", "current", "undefined", "observedEntry", "currentObserver", "refCallback", "rootRefCallback", "rootNode", "useTrackVisibility", "ref", "result", "isVisible", "Boolean", "isIntersecting", "wasEverVisible", "setWasEverVisible"]
}
