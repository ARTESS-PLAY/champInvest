import {
  require_react
} from "./chunk-UTK47NYQ.js";
import {
  __toESM
} from "./chunk-DFKQJ226.js";

// node_modules/react-intersection-observer-hook/dist/react-intersection-observer-hook.esm.js
var import_react = __toESM(require_react());
function createObserverCache() {
  var cachesByRoot = /* @__PURE__ */ new Map();
  function getObserver(_ref) {
    var root = _ref.root, rootMargin = _ref.rootMargin, threshold = _ref.threshold;
    var cacheByRoot = cachesByRoot.get(root);
    if (!cacheByRoot) {
      cacheByRoot = /* @__PURE__ */ new Map();
      cachesByRoot.set(root, cacheByRoot);
    }
    var cacheKey = JSON.stringify({
      rootMargin,
      threshold
    });
    var cachedObserver = cacheByRoot.get(cacheKey);
    if (!cachedObserver) {
      var entryCallbacks = /* @__PURE__ */ new Map();
      var observer = new IntersectionObserver(function(entries) {
        entries.forEach(function(entry) {
          var callback = entryCallbacks.get(entry.target);
          callback == null ? void 0 : callback(entry);
        });
      }, {
        root,
        rootMargin,
        threshold
      });
      cachedObserver = {
        observer,
        entryCallbacks
      };
      cacheByRoot.set(cacheKey, cachedObserver);
    }
    return {
      observe: function observe(node, callback) {
        var _cachedObserver, _cachedObserver2;
        (_cachedObserver = cachedObserver) == null ? void 0 : _cachedObserver.entryCallbacks.set(node, callback);
        (_cachedObserver2 = cachedObserver) == null ? void 0 : _cachedObserver2.observer.observe(node);
      },
      unobserve: function unobserve(node) {
        var _cachedObserver3, _cachedObserver4;
        (_cachedObserver3 = cachedObserver) == null ? void 0 : _cachedObserver3.entryCallbacks["delete"](node);
        (_cachedObserver4 = cachedObserver) == null ? void 0 : _cachedObserver4.observer.unobserve(node);
      }
    };
  }
  return {
    getObserver
  };
}
var DEFAULT_ROOT_MARGIN = "0px";
var DEFAULT_THRESHOLD = [0];
var observerCache = createObserverCache();
function useIntersectionObserver(args) {
  var _args$rootMargin, _args$threshold;
  var rootMargin = (_args$rootMargin = args == null ? void 0 : args.rootMargin) != null ? _args$rootMargin : DEFAULT_ROOT_MARGIN;
  var threshold = (_args$threshold = args == null ? void 0 : args.threshold) != null ? _args$threshold : DEFAULT_THRESHOLD;
  var nodeRef = (0, import_react.useRef)(null);
  var rootRef = (0, import_react.useRef)(null);
  var observerRef = (0, import_react.useRef)(null);
  var _useState = (0, import_react.useState)(), entry = _useState[0], setEntry = _useState[1];
  var observe = (0, import_react.useCallback)(function() {
    var node = nodeRef.current;
    if (!node) {
      setEntry(void 0);
      return;
    }
    var observer = observerCache.getObserver({
      root: rootRef.current,
      rootMargin,
      threshold
    });
    observer.observe(node, function(observedEntry) {
      setEntry(observedEntry);
    });
    observerRef.current = observer;
  }, [rootMargin, threshold]);
  var unobserve = (0, import_react.useCallback)(function() {
    var currentObserver = observerRef.current;
    var node = nodeRef.current;
    if (node) {
      currentObserver == null ? void 0 : currentObserver.unobserve(node);
    }
    observerRef.current = null;
  }, []);
  var refCallback = (0, import_react.useCallback)(function(node) {
    unobserve();
    nodeRef.current = node;
    observe();
  }, [observe, unobserve]);
  var rootRefCallback = (0, import_react.useCallback)(function(rootNode) {
    unobserve();
    rootRef.current = rootNode;
    observe();
  }, [observe, unobserve]);
  return [refCallback, {
    entry,
    rootRef: rootRefCallback
  }];
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function useTrackVisibility(args) {
  var _result$entry;
  var _useIntersectionObser = useIntersectionObserver(args), ref = _useIntersectionObser[0], result = _useIntersectionObser[1];
  var isVisible = Boolean((_result$entry = result.entry) == null ? void 0 : _result$entry.isIntersecting);
  var _useState = (0, import_react.useState)(isVisible), wasEverVisible = _useState[0], setWasEverVisible = _useState[1];
  if (isVisible && !wasEverVisible) {
    setWasEverVisible(true);
  }
  return [ref, _extends({}, result, {
    isVisible,
    wasEverVisible
  })];
}
export {
  useIntersectionObserver,
  useTrackVisibility
};
//# sourceMappingURL=react-intersection-observer-hook.js.map
